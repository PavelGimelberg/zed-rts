<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ZED — Enhanced Isometric Terrain</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #111;
    color: #e0e0e0;
    font-family: 'Segoe UI', system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }
  h1 { padding: 18px 0 4px; font-size: 24px; color: #ff6b6b; letter-spacing: 3px; }
  .sub { color: #888; font-size: 13px; margin-bottom: 12px; }
  canvas { border-radius: 8px; cursor: grab; }
  canvas:active { cursor: grabbing; }
  .controls {
    display: flex; gap: 16px; padding: 10px; flex-wrap: wrap; justify-content: center;
  }
  .controls label { font-size: 13px; color: #aaa; display: flex; align-items: center; gap: 6px; }
  .controls select, .controls input {
    background: #222; color: #ddd; border: 1px solid #444; border-radius: 4px; padding: 3px 6px;
  }
</style>
</head>
<body>
<h1>ZED — ENHANCED ISOMETRIC TERRAIN</h1>
<p class="sub">Perlin noise textures • ambient occlusion • animated water • interactive camera (drag to pan, scroll to zoom)</p>
<div class="controls">
  <label>Tile Size: <select id="tileSize">
    <option value="64">64×32 (Small)</option>
    <option value="96">96×48 (Medium)</option>
    <option value="128" selected>128×64 (Large)</option>
  </select></label>
  <label>Water Anim: <input type="checkbox" id="waterAnim" checked></label>
  <label>Grid Lines: <input type="checkbox" id="gridLines"></label>
</div>
<canvas id="canvas" width="1100" height="620"></canvas>

<script>
// ============================================================
// PERLIN NOISE (classic implementation)
// ============================================================
class PerlinNoise {
  constructor(seed = 42) {
    this.p = new Uint8Array(512);
    const perm = new Uint8Array(256);
    for (let i = 0; i < 256; i++) perm[i] = i;
    // Fisher-Yates shuffle with seed
    let s = seed;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
  }
  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  lerp(a, b, t) { return a + t * (b - a); }
  grad(hash, x, y) {
    const h = hash & 3;
    const u = h < 2 ? x : y;
    const v = h < 2 ? y : x;
    return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
  }
  noise(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    const xf = x - Math.floor(x), yf = y - Math.floor(y);
    const u = this.fade(xf), v = this.fade(yf);
    const p = this.p;
    const aa = p[p[X] + Y], ab = p[p[X] + Y + 1];
    const ba = p[p[X + 1] + Y], bb = p[p[X + 1] + Y + 1];
    return this.lerp(
      this.lerp(this.grad(aa, xf, yf), this.grad(ba, xf - 1, yf), u),
      this.lerp(this.grad(ab, xf, yf - 1), this.grad(bb, xf - 1, yf - 1), u),
      v
    );
  }
  fbm(x, y, octaves = 4) {
    let val = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
      val += this.noise(x * freq, y * freq) * amp;
      max += amp;
      amp *= 0.5;
      freq *= 2;
    }
    return val / max;
  }
}

const perlin = new PerlinNoise(42);
const perlin2 = new PerlinNoise(137);

// ============================================================
// MAP DATA (same 12×8 sample)
// ============================================================
const MAP = [
  [3, 3, 0, 0, 0, 2, 0, 0, 0, 0, 4, 4],
  [3, 0, 0, 0, 0, 2, 0, 0, 0, 4, 4, 0],
  [0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0],
  [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 3],
  [0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 3, 3],
  [4, 4, 0, 0, 0, 2, 0, 0, 0, 3, 3, 3],
];
const ROWS = MAP.length, COLS = MAP[0].length;

// ============================================================
// TILE SPRITE CACHE (pre-rendered offscreen)
// ============================================================
const tileCache = {};
let TW = 128, TH = 64, HW = 64, HH = 32;

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return [r, g, b];
}

function rgbStr(r, g, b) { return `rgb(${r|0},${g|0},${b|0})`; }

// Check if point (px,py) is inside diamond centered at (cx,cy)
function inDiamond(px, py, cx, cy, hw, hh) {
  return Math.abs(px - cx) / hw + Math.abs(py - cy) / hh <= 1;
}

// Generate a single tile sprite using Perlin noise
function generateTileSprite(tileType, col, row, time) {
  const oc = document.createElement('canvas');
  oc.width = TW + 2;
  oc.height = TH + 2;
  const ctx = oc.getContext('2d');
  const cx = (TW + 2) / 2, cy = (TH + 2) / 2;

  // Per-pixel rendering for noise-based textures
  const imgData = ctx.createImageData(oc.width, oc.height);
  const data = imgData.data;

  for (let py = 0; py < oc.height; py++) {
    for (let px = 0; px < oc.width; px++) {
      if (!inDiamond(px, py, cx, cy, HW + 0.5, HH + 0.5)) continue;

      // World-space noise coordinates
      const wx = (col + (px - cx + HW) / TW) * 1.0;
      const wy = (row + (py - cy + HH) / TH) * 1.0;

      let r, g, b, a = 255;
      const n1 = perlin.fbm(wx * 3, wy * 3, 4) * 0.5 + 0.5;
      const n2 = perlin2.fbm(wx * 5, wy * 5, 3) * 0.5 + 0.5;
      const n3 = perlin.fbm(wx * 8, wy * 8, 2) * 0.5 + 0.5;

      if (tileType === 0) {
        // GRASS: lush green with variation
        const base_r = 55 + n1 * 35;
        const base_g = 120 + n1 * 50 + n2 * 20;
        const base_b = 40 + n1 * 20;
        // Add blade detail
        const blade = perlin.noise(wx * 20, wy * 20) * 0.5 + 0.5;
        r = base_r + blade * 15 - 8;
        g = base_g + blade * 25 - 12;
        b = base_b + blade * 10 - 5;
      } else if (tileType === 1) {
        // WATER: deep blue with waves
        const wave = Math.sin(wx * 6 + time * 0.03) * Math.cos(wy * 4 + time * 0.02);
        const depth = n1 * 0.4 + 0.6;
        r = 20 + n2 * 30 + wave * 15;
        g = 60 + depth * 40 + wave * 20 + n2 * 25;
        b = 140 + depth * 60 + wave * 25 + n1 * 30;
        // Specular highlights
        const spec = perlin.noise(wx * 12 + time * 0.05, wy * 12 + time * 0.03);
        if (spec > 0.35) {
          const s = (spec - 0.35) * 3;
          r += s * 80; g += s * 80; b += s * 60;
        }
      } else if (tileType === 2) {
        // ROAD: packed earth/stone
        const grain = n3 * 0.3;
        r = 145 + n1 * 35 + grain * 30;
        g = 120 + n1 * 30 + grain * 25;
        b = 85 + n1 * 20 + grain * 15;
        // Occasional pebbles
        const pebble = perlin.noise(wx * 25, wy * 25);
        if (pebble > 0.3) {
          const p = (pebble - 0.3) * 2;
          r += p * 25; g += p * 20; b += p * 15;
        }
        // Track lines
        const track = Math.abs(Math.sin(wy * 15 + n1 * 2));
        if (track > 0.92) { r -= 15; g -= 12; b -= 8; }
      } else if (tileType === 3) {
        // MOUNTAIN: rocky grey-brown
        const rock = n1 * 0.6 + n3 * 0.4;
        r = 95 + rock * 55 + n2 * 20;
        g = 85 + rock * 45 + n2 * 15;
        b = 70 + rock * 35 + n2 * 10;
        // Cracks
        const crack = perlin.noise(wx * 15, wy * 15);
        if (Math.abs(crack) < 0.06) { r -= 30; g -= 25; b -= 20; }
        // Snow on top (upper portion of diamond)
        const dy = (py - cy) / HH;
        if (dy < -0.3 && n1 > 0.45) {
          const snow = Math.min(1, (-0.3 - dy) * 3 * n1);
          r = r * (1 - snow) + 230 * snow;
          g = g * (1 - snow) + 235 * snow;
          b = b * (1 - snow) + 240 * snow;
        }
      } else if (tileType === 4) {
        // DIRT: warm brown earth
        r = 140 + n1 * 40 + n3 * 15;
        g = 105 + n1 * 30 + n3 * 10;
        b = 60 + n1 * 25 + n3 * 8;
        // Pebbles and roots
        const detail = perlin.noise(wx * 18, wy * 18);
        if (detail > 0.25) {
          r += 15; g += 10; b += 5;
        }
        if (detail < -0.3) {
          r -= 20; g -= 15; b -= 8;
        }
      }

      // Ambient occlusion at diamond edges
      const edgeDist = 1 - (Math.abs(px - cx) / HW + Math.abs(py - cy) / HH);
      const ao = Math.min(1, edgeDist * 5);
      r *= (0.7 + 0.3 * ao);
      g *= (0.7 + 0.3 * ao);
      b *= (0.7 + 0.3 * ao);

      // Subtle directional lighting (top-left light)
      const dx = (px - cx) / HW;
      const dy2 = (py - cy) / HH;
      const light = 1 + (-dx * 0.12 + -dy2 * 0.08);
      r *= light; g *= light; b *= light;

      const idx = (py * oc.width + px) * 4;
      data[idx] = Math.max(0, Math.min(255, r));
      data[idx + 1] = Math.max(0, Math.min(255, g));
      data[idx + 2] = Math.max(0, Math.min(255, b));
      data[idx + 3] = a;
    }
  }
  ctx.putImageData(imgData, 0, 0);

  // Mountain peaks overlay (drawn with canvas API for smooth shapes)
  if (tileType === 3) {
    const rng = mulberry32(col * 100 + row);
    for (let p = 0; p < 2; p++) {
      const pkx = cx + (rng() - 0.5) * HW * 0.6;
      const pky = cy + (rng() - 0.5) * HH * 0.5;
      const ph = 14 + rng() * 16;
      const pw = 8 + rng() * 6;
      // Shadow side
      ctx.beginPath();
      ctx.moveTo(pkx, pky + 3);
      ctx.lineTo(pkx + 1, pky - ph);
      ctx.lineTo(pkx + pw, pky + 3);
      ctx.closePath();
      ctx.fillStyle = `rgba(60,50,40,0.8)`;
      ctx.fill();
      // Lit side
      ctx.beginPath();
      ctx.moveTo(pkx, pky + 3);
      ctx.lineTo(pkx + 1, pky - ph);
      ctx.lineTo(pkx - pw + 2, pky + 3);
      ctx.closePath();
      ctx.fillStyle = `rgba(120,105,85,0.9)`;
      ctx.fill();
      // Snow cap
      ctx.beginPath();
      ctx.moveTo(pkx - pw * 0.3, pky - ph + 6);
      ctx.lineTo(pkx + 1, pky - ph);
      ctx.lineTo(pkx + pw * 0.3, pky - ph + 6);
      ctx.closePath();
      ctx.fillStyle = '#e8eaef';
      ctx.fill();
    }
  }

  return oc;
}

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ============================================================
// RENDERING
// ============================================================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let camX = 0, camY = 0, zoom = 1;
let dragging = false, lastMX = 0, lastMY = 0;
let animTime = 0;

function isoToScreen(col, row) {
  const x = (col - row) * HW * zoom + canvas.width / 2 + camX;
  const y = (col + row) * HH * zoom + 30 + camY;
  return { x, y };
}

function rebuildCache(time) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const tile = MAP[r][c];
      const key = `${c}_${r}_${tile}_${TW}`;
      // Only rebuild water tiles for animation, cache others permanently
      if (tile === 1 || !tileCache[key]) {
        tileCache[key] = generateTileSprite(tile, c, r, time);
      }
    }
  }
}

function render() {
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Rebuild water tiles for animation
  const showWater = document.getElementById('waterAnim').checked;
  if (showWater && animTime % 4 === 0) {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (MAP[r][c] === 1) {
          const key = `${c}_${r}_1_${TW}`;
          tileCache[key] = generateTileSprite(1, c, r, animTime);
        }
      }
    }
  }

  const showGrid = document.getElementById('gridLines').checked;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const { x, y } = isoToScreen(c, r);
      const key = `${c}_${r}_${MAP[r][c]}_${TW}`;
      const sprite = tileCache[key];
      if (sprite) {
        const sw = (TW + 2) * zoom;
        const sh = (TH + 2) * zoom;
        ctx.drawImage(sprite, x - sw / 2, y - sh / 2, sw, sh);
      }

      // Grid lines
      if (showGrid) {
        ctx.beginPath();
        ctx.moveTo(x, y - HH * zoom);
        ctx.lineTo(x + HW * zoom, y);
        ctx.lineTo(x, y + HH * zoom);
        ctx.lineTo(x - HW * zoom, y);
        ctx.closePath();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    }
  }

  animTime++;
  requestAnimationFrame(render);
}

// Camera controls
canvas.addEventListener('mousedown', e => { dragging = true; lastMX = e.clientX; lastMY = e.clientY; });
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  camX += e.clientX - lastMX;
  camY += e.clientY - lastMY;
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const oldZoom = zoom;
  zoom *= e.deltaY > 0 ? 0.92 : 1.08;
  zoom = Math.max(0.3, Math.min(3, zoom));
  // Zoom toward cursor
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left - canvas.width / 2 - camX;
  const my = e.clientY - rect.top - 30 - camY;
  camX -= mx * (zoom / oldZoom - 1);
  camY -= my * (zoom / oldZoom - 1);
}, { passive: false });

// Tile size control
document.getElementById('tileSize').addEventListener('change', e => {
  TW = parseInt(e.target.value);
  TH = TW / 2;
  HW = TW / 2;
  HH = TH / 2;
  // Clear cache to force rebuild
  Object.keys(tileCache).forEach(k => delete tileCache[k]);
  rebuildCache(animTime);
});

// Initial build
rebuildCache(0);
render();
</script>
</body>
</html>
