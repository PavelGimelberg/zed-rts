<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ZED — Tile Comparison: SBS vs Perlin</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#1a1a2e; color:#eee; font-family:'Segoe UI',sans-serif; overflow-x:hidden; }
  h1 { text-align:center; padding:16px; color:#ff6b6b; font-size:28px; }
  .subtitle { text-align:center; color:#888; margin-bottom:12px; font-size:14px; }
  .container { display:flex; gap:8px; padding:0 8px; height:calc(100vh - 100px); }
  .panel { flex:1; position:relative; border:2px solid #333; border-radius:8px; overflow:hidden; }
  .panel-label {
    position:absolute; top:8px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,0.8); padding:6px 16px; border-radius:20px;
    font-weight:bold; z-index:10; font-size:14px; white-space:nowrap;
  }
  .panel-label.sbs { color:#4ecdc4; border:1px solid #4ecdc4; }
  .panel-label.perlin { color:#ff6b6b; border:1px solid #ff6b6b; }
  canvas { width:100%; height:100%; display:block; cursor:grab; }
  canvas:active { cursor:grabbing; }
  .controls { text-align:center; padding:8px; display:flex; justify-content:center; gap:20px; align-items:center; }
  .controls label { font-size:13px; color:#aaa; }
  .controls select { background:#2a2a4a; color:#eee; border:1px solid #555; padding:4px 8px; border-radius:4px; }
  .controls button { background:#4ecdc4; color:#111; border:none; padding:6px 14px; border-radius:4px; cursor:pointer; font-weight:bold; }
  .controls button:hover { background:#45b7af; }
  #loading { position:fixed; inset:0; background:rgba(0,0,0,0.9); display:flex; align-items:center;
    justify-content:center; z-index:100; font-size:24px; color:#ff6b6b; }
</style>
</head>
<body>
<div id="loading">Loading tile sheets & generating Perlin tiles...</div>
<h1>ZED — Tile Comparison</h1>
<div class="controls">
  <label>Map: <select id="mapSelect">
    <option value="game">Game Map (40×28)</option>
    <option value="demo">Demo Map (16×16)</option>
  </select></label>
  <button id="syncBtn">Sync Cameras</button>
  <label><input type="checkbox" id="gridCheck"> Grid Lines</label>
  <label><input type="checkbox" id="animCheck" checked> Animate Water</label>
</div>
<div class="container">
  <div class="panel">
    <div class="panel-label sbs">Screaming Brain Studios (CC0)</div>
    <canvas id="sbsCanvas"></canvas>
  </div>
  <div class="panel">
    <div class="panel-label perlin">Procedural Perlin Noise</div>
    <canvas id="perlinCanvas"></canvas>
  </div>
</div>

<script>
// ============================================================
// CONFIGURATION
// ============================================================
const TILE_W = 256, TILE_H = 128;
const HALF_W = TILE_W / 2, HALF_H = TILE_H / 2;

// Tile types matching our game
const GRASS = 0, WATER = 1, ROAD = 2, MOUNTAIN = 3, DIRT = 4;

// ============================================================
// MAP DATA
// ============================================================
// Same map layout from our game's mapGenerator pattern
const GAME_MAP_COLS = 40, GAME_MAP_ROWS = 28;
function generateGameMap() {
  const map = [];
  for (let r = 0; r < GAME_MAP_ROWS; r++) {
    map[r] = [];
    for (let c = 0; c < GAME_MAP_COLS; c++) {
      // Water lake in center
      const cx = GAME_MAP_COLS/2, cy = GAME_MAP_ROWS/2;
      const dist = Math.sqrt((c-cx)**2 + (r-cy)**2);
      if (dist < 4) { map[r][c] = WATER; continue; }
      // Mountains at corners
      const corners = [[3,3],[36,3],[3,24],[36,24]];
      let nearCorner = false;
      for (const [mx,my] of corners) {
        if (Math.abs(c-mx) < 3 && Math.abs(r-my) < 3) { nearCorner = true; break; }
      }
      if (nearCorner) { map[r][c] = MOUNTAIN; continue; }
      // Roads
      if (r === Math.floor(GAME_MAP_ROWS/2) || c === Math.floor(GAME_MAP_COLS/2)) { map[r][c] = ROAD; continue; }
      // Dirt patches
      if ((c + r) % 11 === 0 || (c * 3 + r * 7) % 23 === 0) { map[r][c] = DIRT; continue; }
      map[r][c] = GRASS;
    }
  }
  return { map, cols: GAME_MAP_COLS, rows: GAME_MAP_ROWS };
}

const DEMO_COLS = 16, DEMO_ROWS = 16;
function generateDemoMap() {
  const map = [];
  for (let r = 0; r < DEMO_ROWS; r++) {
    map[r] = [];
    for (let c = 0; c < DEMO_COLS; c++) {
      const cx = 8, cy = 8, dist = Math.sqrt((c-cx)**2 + (r-cy)**2);
      if (dist < 2.5) { map[r][c] = WATER; }
      else if (r < 3 || r > 12) { map[r][c] = (c + r) % 3 === 0 ? MOUNTAIN : DIRT; }
      else if (c === 8 || r === 8) { map[r][c] = ROAD; }
      else { map[r][c] = GRASS; }
    }
  }
  return { map, cols: DEMO_COLS, rows: DEMO_ROWS };
}

let currentMapData = generateGameMap();

// ============================================================
// SPRITE SHEET LOADING (SBS tiles)
// ============================================================
const SHEET_COLS = 3, SHEET_ROWS = 6;
const sheetPaths = {
  forest: 'tiles/Overworld - Forest - Flat 256x128.png',
  terrain1: 'tiles/Overworld - Terrain 1 - Flat 256x128.png',
  terrain2: 'tiles/Overworld - Terrain 2 - Flat 256x128.png',
  terrain3: 'tiles/Overworld - Terrain 3 - Flat 256x128.png',
  water: 'tiles/Overworld - Water - Flat 256x128.png',
};
// Transparency colors
const transColors = {
  forest: [0,0,0],
  terrain1: [0,0,0],
  terrain2: [0,0,0],
  terrain3: [255,0,255],
  water: [255,0,255],
};

// Map tile types to sheet + indices (pick best-looking tiles)
const tileMapping = {
  [GRASS]:    { sheet: 'forest',   indices: [0, 1, 2, 3, 6, 7] },
  [WATER]:    { sheet: 'water',    indices: [0, 1, 2, 3, 4, 5] },
  [ROAD]:     { sheet: 'terrain2', indices: [0, 1, 2] },
  [MOUNTAIN]: { sheet: 'terrain3', indices: [0, 1, 2, 3, 4, 5] },
  [DIRT]:     { sheet: 'terrain1', indices: [0, 1, 2, 3, 4, 5] },
};

const sheetImages = {};
const extractedTiles = {}; // { sheetName: [canvas, canvas, ...] }

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error('Failed to load: ' + src));
    img.src = src;
  });
}

function extractTilesFromSheet(img, sheetName) {
  const tc = transColors[sheetName];
  const tiles = [];
  for (let row = 0; row < SHEET_ROWS; row++) {
    for (let col = 0; col < SHEET_COLS; col++) {
      const sx = col * TILE_W, sy = row * TILE_H;
      const c = document.createElement('canvas');
      c.width = TILE_W; c.height = TILE_H;
      const ctx = c.getContext('2d');
      ctx.drawImage(img, sx, sy, TILE_W, TILE_H, 0, 0, TILE_W, TILE_H);
      // Remove transparency color
      const imgData = ctx.getImageData(0, 0, TILE_W, TILE_H);
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const dr = Math.abs(d[i] - tc[0]);
        const dg = Math.abs(d[i+1] - tc[1]);
        const db = Math.abs(d[i+2] - tc[2]);
        if (dr < 15 && dg < 15 && db < 15) {
          d[i+3] = 0; // transparent
        }
      }
      ctx.putImageData(imgData, 0, 0);
      tiles.push(c);
    }
  }
  return tiles;
}

function getSBSTile(tileType, col, row) {
  const mapping = tileMapping[tileType];
  if (!mapping) return null;
  const tiles = extractedTiles[mapping.sheet];
  if (!tiles) return null;
  const idx = mapping.indices[(col * 7 + row * 13) % mapping.indices.length];
  return tiles[idx] || tiles[0];
}

// ============================================================
// PERLIN NOISE (same as enhanced demo)
// ============================================================
class PerlinNoise {
  constructor(seed = 42) {
    this.p = new Uint8Array(512);
    const perm = new Uint8Array(256);
    for (let i = 0; i < 256; i++) perm[i] = i;
    let s = seed;
    for (let i = 255; i > 0; i--) {
      s = (s * 16807 + 0) % 2147483647;
      const j = s % (i + 1);
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }
    for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
  }
  fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  lerp(a, b, t) { return a + t * (b - a); }
  grad(hash, x, y) {
    const h = hash & 3;
    return ((h & 1) ? -x : x) + ((h & 2) ? -y : y);
  }
  noise(x, y) {
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
    x -= Math.floor(x); y -= Math.floor(y);
    const u = this.fade(x), v = this.fade(y);
    const A = this.p[X] + Y, B = this.p[X + 1] + Y;
    return this.lerp(
      this.lerp(this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y), u),
      this.lerp(this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1), u), v
    );
  }
  fbm(x, y, octaves = 4) {
    let val = 0, amp = 0.5, freq = 1;
    for (let i = 0; i < octaves; i++) {
      val += amp * this.noise(x * freq, y * freq);
      amp *= 0.5; freq *= 2;
    }
    return val;
  }
}

const perlin = new PerlinNoise(42);
const perlinTileCache = {};

function generatePerlinTile(tileType, col, row) {
  const key = `${tileType}_${col}_${row}`;
  if (perlinTileCache[key]) return perlinTileCache[key];

  const c = document.createElement('canvas');
  c.width = TILE_W; c.height = TILE_H;
  const ctx = c.getContext('2d');
  const imgData = ctx.createImageData(TILE_W, TILE_H);
  const d = imgData.data;
  const seed = col * 137 + row * 311;

  for (let py = 0; py < TILE_H; py++) {
    for (let px = 0; px < TILE_W; px++) {
      // Check if pixel is inside diamond
      const relX = (px - HALF_W) / HALF_W;
      const relY = (py - HALF_H) / HALF_H;
      const diamond = Math.abs(relX) + Math.abs(relY);
      if (diamond > 1.0) continue;

      const nx = (col * TILE_W + px) / 200;
      const ny = (row * TILE_H + py) / 200;
      const n = perlin.fbm(nx + seed * 0.01, ny + seed * 0.007, 4);

      // Ambient occlusion at edges
      const edgeDist = 1.0 - diamond;
      const ao = Math.min(1, edgeDist * 4);

      // Directional light (top-left)
      const light = 0.85 + 0.15 * (1 - (px / TILE_W) * 0.5 - (py / TILE_H) * 0.5);

      let r, g, b;
      const idx = (py * TILE_W + px) * 4;

      switch (tileType) {
        case GRASS: {
          const base = 0.45 + n * 0.3;
          r = Math.floor((40 + n * 30) * ao * light);
          g = Math.floor((120 + n * 80) * base * ao * light);
          b = Math.floor((25 + n * 20) * ao * light);
          // Grass blades
          const blade = perlin.noise(px * 0.3 + seed, py * 0.3) * 0.5;
          if (blade > 0.3) { g += 20; r -= 5; }
          break;
        }
        case WATER: {
          const t = (typeof waterTime !== 'undefined' ? waterTime : 0);
          const wave = Math.sin(px * 0.05 + py * 0.03 + t * 2 + n * 3) * 0.5 + 0.5;
          r = Math.floor((30 + wave * 40) * ao);
          g = Math.floor((80 + wave * 60 + n * 30) * ao);
          b = Math.floor((160 + wave * 60 + n * 40) * ao);
          // Specular highlights
          const spec = Math.sin(px * 0.08 + t * 3) * Math.cos(py * 0.06 + t * 2.5);
          if (spec > 0.6) { r += 60; g += 60; b += 60; }
          break;
        }
        case ROAD: {
          const base = 0.6 + n * 0.2;
          r = Math.floor(140 * base * ao * light);
          g = Math.floor(130 * base * ao * light);
          b = Math.floor(110 * base * ao * light);
          // Track marks
          const track = Math.abs(Math.sin(py * 0.15 + n * 2));
          if (track > 0.85) { r -= 15; g -= 15; b -= 15; }
          break;
        }
        case MOUNTAIN: {
          const base = 0.5 + n * 0.3;
          r = Math.floor(100 * base * ao * light);
          g = Math.floor(95 * base * ao * light);
          b = Math.floor(85 * base * ao * light);
          // Snow caps
          if (py < TILE_H * 0.3 && n > 0.1) {
            const snow = (TILE_H * 0.3 - py) / (TILE_H * 0.3);
            r = Math.floor(r + (220 - r) * snow * 0.7);
            g = Math.floor(g + (225 - g) * snow * 0.7);
            b = Math.floor(b + (230 - b) * snow * 0.7);
          }
          // Cracks
          const crack = perlin.noise(px * 0.1 + seed, py * 0.15);
          if (Math.abs(crack) < 0.05) { r -= 20; g -= 20; b -= 20; }
          break;
        }
        case DIRT: {
          const base = 0.55 + n * 0.25;
          r = Math.floor(150 * base * ao * light);
          g = Math.floor(110 * base * ao * light);
          b = Math.floor(70 * base * ao * light);
          // Pebbles
          const peb = perlin.noise(px * 0.2 + seed, py * 0.2);
          if (peb > 0.35) { r += 12; g += 8; b += 5; }
          break;
        }
      }
      d[idx] = Math.max(0, Math.min(255, r));
      d[idx+1] = Math.max(0, Math.min(255, g));
      d[idx+2] = Math.max(0, Math.min(255, b));
      d[idx+3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
  perlinTileCache[key] = c;
  return c;
}

// ============================================================
// CAMERA & RENDERING
// ============================================================
class Camera {
  constructor() { this.x = 0; this.y = 0; this.zoom = 0.35; }
  centerOn(cols, rows) {
    // Center camera on map center in isometric coordinates
    const cx = (cols / 2 - rows / 2) * HALF_W;
    const cy = (cols / 2 + rows / 2) * HALF_H;
    this.x = cx;
    this.y = cy - 100;
  }
}

function isoToScreen(col, row, cam, cw, ch) {
  const wx = (col - row) * HALF_W;
  const wy = (col + row) * HALF_H;
  const sx = (wx - cam.x) * cam.zoom + cw / 2;
  const sy = (wy - cam.y) * cam.zoom + ch / 2;
  return { x: sx, y: sy };
}

function renderMap(ctx, mapData, cam, mode, showGrid) {
  const cw = ctx.canvas.width, ch = ctx.canvas.height;
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, cw, ch);

  const { map, cols, rows } = mapData;
  const tileW = TILE_W * cam.zoom;
  const tileH = TILE_H * cam.zoom;

  // Draw back-to-front
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const { x, y } = isoToScreen(col, row, cam, cw, ch);
      // Frustum culling
      if (x + tileW < -tileW || x - tileW > cw + tileW || y + tileH < -tileH || y - tileH > ch + tileH) continue;

      const tileType = map[row][col];
      let tileSpr;

      if (mode === 'sbs') {
        tileSpr = getSBSTile(tileType, col, row);
      } else {
        tileSpr = generatePerlinTile(tileType, col, row);
      }

      if (tileSpr) {
        ctx.drawImage(tileSpr, x - tileW/2, y - tileH/2, tileW, tileH);
      }

      if (showGrid) {
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(x, y - tileH/2);
        ctx.lineTo(x + tileW/2, y);
        ctx.lineTo(x, y + tileH/2);
        ctx.lineTo(x - tileW/2, y);
        ctx.closePath();
        ctx.stroke();
      }
    }
  }
}

// ============================================================
// SETUP CANVASES
// ============================================================
const sbsCanvas = document.getElementById('sbsCanvas');
const perlinCanvas = document.getElementById('perlinCanvas');
const sbsCtx = sbsCanvas.getContext('2d');
const perlinCtx = perlinCanvas.getContext('2d');

const sbsCam = new Camera();
const perlinCam = new Camera();

function resize() {
  const panels = document.querySelectorAll('.panel');
  panels.forEach((p, i) => {
    const rect = p.getBoundingClientRect();
    const cvs = i === 0 ? sbsCanvas : perlinCanvas;
    cvs.width = rect.width;
    cvs.height = rect.height;
  });
}

// ============================================================
// MOUSE INTERACTION (drag to pan, scroll to zoom)
// ============================================================
function setupInteraction(canvas, cam) {
  let dragging = false, lastX, lastY;
  canvas.addEventListener('mousedown', e => {
    dragging = true; lastX = e.clientX; lastY = e.clientY;
  });
  canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    const dx = e.clientX - lastX, dy = e.clientY - lastY;
    cam.x -= dx / cam.zoom;
    cam.y -= dy / cam.zoom;
    lastX = e.clientX; lastY = e.clientY;
  });
  canvas.addEventListener('mouseup', () => dragging = false);
  canvas.addEventListener('mouseleave', () => dragging = false);
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    cam.zoom = Math.max(0.1, Math.min(2, cam.zoom * factor));
  }, { passive: false });
}

// ============================================================
// ANIMATION LOOP
// ============================================================
let waterTime = 0;
let showGrid = false;
let animateWater = true;

function gameLoop(timestamp) {
  if (animateWater) waterTime = timestamp / 1000;

  renderMap(sbsCtx, currentMapData, sbsCam, 'sbs', showGrid);
  renderMap(perlinCtx, currentMapData, perlinCam, 'perlin', showGrid);

  requestAnimationFrame(gameLoop);
}

// ============================================================
// CONTROLS
// ============================================================
document.getElementById('mapSelect').addEventListener('change', e => {
  currentMapData = e.target.value === 'game' ? generateGameMap() : generateDemoMap();
  // Clear perlin cache for new map
  Object.keys(perlinTileCache).forEach(k => delete perlinTileCache[k]);
  sbsCam.centerOn(currentMapData.cols, currentMapData.rows);
  perlinCam.centerOn(currentMapData.cols, currentMapData.rows);
});

document.getElementById('syncBtn').addEventListener('click', () => {
  perlinCam.x = sbsCam.x;
  perlinCam.y = sbsCam.y;
  perlinCam.zoom = sbsCam.zoom;
});

document.getElementById('gridCheck').addEventListener('change', e => showGrid = e.target.checked);
document.getElementById('animCheck').addEventListener('change', e => animateWater = e.target.checked);

// ============================================================
// INIT
// ============================================================
async function init() {
  resize();
  window.addEventListener('resize', resize);

  // Load all sprite sheets
  const loadPromises = Object.entries(sheetPaths).map(async ([name, path]) => {
    const img = await loadImage(path);
    sheetImages[name] = img;
    extractedTiles[name] = extractTilesFromSheet(img, name);
    console.log(`Loaded ${name}: ${extractedTiles[name].length} tiles`);
  });

  await Promise.all(loadPromises);
  console.log('All sheets loaded!');

  // Center cameras
  sbsCam.centerOn(currentMapData.cols, currentMapData.rows);
  perlinCam.centerOn(currentMapData.cols, currentMapData.rows);

  // Pre-generate a few perlin tiles to warm up
  const { map, cols, rows } = currentMapData;
  for (let r = 0; r < Math.min(rows, 10); r++) {
    for (let c = 0; c < Math.min(cols, 10); c++) {
      generatePerlinTile(map[r][c], c, r);
    }
  }

  // Setup interaction
  setupInteraction(sbsCanvas, sbsCam);
  setupInteraction(perlinCanvas, perlinCam);

  document.getElementById('loading').style.display = 'none';
  requestAnimationFrame(gameLoop);
}

init().catch(e => {
  document.getElementById('loading').textContent = 'Error: ' + e.message;
  console.error(e);
});
</script>
</body>
</html>
